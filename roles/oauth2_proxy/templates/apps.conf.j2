# Configuration Multi-Applications
# Generated by Ansible role: oauth2_proxy
#
# Architecture simplifiee :
# - Guacamole : OIDC natif vers Keycloak (pas d'oauth2-proxy)
# - Portail : oauth2-proxy pour authentification
# - Autres apps : oauth2-proxy ou OIDC natif selon l'application

# Resolver Docker pour résolution dynamique des upstreams
# Permet à nginx de démarrer même si certains services ne sont pas disponibles
resolver 127.0.0.11 valid=10s ipv6=off;

# Upstreams dynamiques (résolus à la demande, pas au démarrage)
# Utiliser ces variables dans proxy_pass pour éviter les erreurs si le service n'est pas encore up
map $host $upstream_oauth2 {
    default http://{{ oauth2_proxy_container_name }}:{{ oauth2_proxy_port_http }};
}
map $host $upstream_guacamole {
    default http://guacamole-web:8080;
}
map $host $upstream_credentials {
    default http://credentials-api:5000;
}
map $host $upstream_portal_api {
    default http://portal-api:3000;
}

# Configuration commune WebSocket
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

# =============================================================================
# HTTP -> HTTPS Redirect (default_server sur port 80)
# =============================================================================
# Le port 80 redirige vers HTTPS pour eviter les problemes de cookies Secure
# (oauth2-proxy utilise cookie_secure=true, incompatible avec HTTP)
server {
    listen 80 default_server;
    server_name _;

    return 301 https://$host$request_uri;
}

# =============================================================================
# PORTAIL HTTPS - Interface web authentifiee
# =============================================================================

# =============================================================================
# PORTAIL HTTPS - Interface web authentifiee
# =============================================================================
server {
    listen 443 ssl default_server;
    http2 on;
    server_name {{ portal_hostname_resolved }} _;

    ssl_certificate /certs/wildcard.{{ domain }}.crt;
    ssl_certificate_key /certs/wildcard.{{ domain }}.key;

    root /usr/share/nginx/html/portal;
    index index.html;

    # Authentification via oauth2-proxy
    auth_request /oauth2/auth;
    error_page 401 = /oauth2/sign_in;

    # Recuperer les informations utilisateur depuis oauth2-proxy
    auth_request_set $auth_user $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    auth_request_set $auth_groups $upstream_http_x_auth_request_groups;
    auth_request_set $auth_preferred_username $upstream_http_x_auth_request_preferred_username;

    # Fichiers statiques du portail
    location / {
        try_files $uri $uri/ /index.html;
        # Pas de cache pour forcer re-authentification
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
        # Injecter les headers utilisateur pour le JavaScript
        add_header X-Auth-User $auth_user;
        add_header X-Auth-Email $auth_email;
        add_header X-Auth-Groups $auth_groups;
    }

    # API endpoint - expose les infos utilisateur en JSON
    # Proxy vers oauth2-proxy userinfo pour obtenir les claims
    location /api/user {
        auth_request off;
        proxy_pass $upstream_oauth2/oauth2/userinfo;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # API applications - liste des applications disponibles (statique)
    # TODO: Remplacer par un backend dynamique si necessaire
    location /api/applications {
        default_type application/json;
        return 200 '[{"id":"guacamole","name":"Guacamole","url":"https://{{ guacamole_hostname_resolved }}/guacamole/","icon":"desktop","description":"Bastion RDP/SSH/VNC","groups":["{{ admin_group }}","{{ admin_app_group }}","{{ user_group }}"]},{"id":"linshare","name":"LinShare","url":"https://{{ linshare_hostname_resolved }}/","icon":"folder","description":"Partage de fichiers","groups":["{{ admin_group }}","{{ admin_app_group }}","{{ user_group }}"]},{"id":"vaultwarden","name":"Vaultwarden","url":"https://{{ vaultwarden_hostname_resolved }}/","icon":"lock","description":"Gestionnaire de mots de passe","groups":["{{ admin_group }}","{{ admin_app_group }}","{{ user_group }}"]}]';
    }

    # API Keycloak clients - non disponible (fonctionnalite optionnelle)
    location /api/keycloak/clients {
        default_type application/json;
        return 200 '[]';
    }

    # API credentials - stockage securise des mots de passe RDP
    location /api/credentials {
        proxy_pass $upstream_credentials/api/credentials;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_preferred_username;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # API connections - liste les connexions Guacamole disponibles
    location /api/connections {
        proxy_pass $upstream_credentials/api/connections;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_preferred_username;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # Logout complet (oauth2-proxy + Keycloak)
    location = /logout {
        default_type text/html;
        return 200 '<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Deconnexion...</title>
    <script>
        // Supprimer tous les cookies oauth2-proxy
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Domain=.{{ domain }}";
        document.cookie = "_oauth2_proxy_csrf=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
        document.cookie = "_oauth2_proxy_csrf=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Domain=.{{ domain }}";

        // Appeler sign_out oauth2-proxy puis logout Keycloak
        fetch("/oauth2/sign_out", { method: "GET", credentials: "include" })
            .finally(function() {
                var keycloakLogout = "{{ keycloak_issuer }}/protocol/openid-connect/logout";
                // Rediriger vers /oauth2/sign_in pour forcer la re-authentification
                var redirectUri = encodeURIComponent("https://portail.{{ domain }}/oauth2/sign_in");
                window.location.href = keycloakLogout + "?post_logout_redirect_uri=" + redirectUri + "&client_id={{ oauth2_proxy_client_id }}";
            });
    </script>
</head>
<body><p>Deconnexion en cours...</p></body>
</html>';
    }

    # Endpoints oauth2-proxy (exempts d'authentification)
    location /oauth2/ {
        auth_request off;
        proxy_pass $upstream_oauth2;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location = /oauth2/auth {
        internal;
        proxy_pass $upstream_oauth2/oauth2/auth;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Content-Length "";
        proxy_pass_request_body off;
    }
}

# =============================================================================
# GUACAMOLE - Bastion d'acces distant (OIDC natif)
# =============================================================================
# Architecture simplifiee : nginx (proxy SSL) -> Guacamole (OIDC -> Keycloak)
# L'authentification est geree directement par Guacamole via OpenID Connect
# Pas besoin d'oauth2-proxy ni de manipulation de headers

server {
    listen 443 ssl;
    http2 on;
    server_name {{ guacamole_hostname_resolved }};

    ssl_certificate /certs/wildcard.{{ domain }}.crt;
    ssl_certificate_key /certs/wildcard.{{ domain }}.key;

    # Proxy simple vers Guacamole (pas d'auth_request)
    # L'authentification OIDC est geree par Guacamole lui-meme
    location / {
        proxy_pass $upstream_guacamole;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support (critique pour Guacamole)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        proxy_buffering off;
    }
}

# GLPI - Gestion des tickets (admin-* et utilisateurs)
# IMPORTANT: Décommenter après avoir déployé glpi-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name glpi.{{ domain }};
#
#     ssl_certificate /certs/wildcard.{{ domain }}.crt;
#     ssl_certificate_key /certs/wildcard.{{ domain }}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     location / {
#         proxy_pass http://glpi-backend:80;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# Zabbix - Monitoring (admin-* uniquement)
# IMPORTANT: Décommenter après avoir déployé zabbix-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name zabbix.{{ domain }};
#
#     ssl_certificate /certs/wildcard.{{ domain }}.crt;
#     ssl_certificate_key /certs/wildcard.{{ domain }}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     # Restriction admin-*
#     set $authorized 0;
#     if ($groups ~ "admin-") {
#         set $authorized 1;
#     }
#     if ($authorized = 0) {
#         return 403 "Access forbidden - Admin group required";
#     }
#
#     location / {
#         proxy_pass http://zabbix-backend:8080;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# Nextcloud - Partage de fichiers (admin-* et utilisateurs)
# IMPORTANT: Décommenter après avoir déployé nextcloud-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name nextcloud.{{ domain }};
#
#     ssl_certificate /certs/wildcard.{{ domain }}.crt;
#     ssl_certificate_key /certs/wildcard.{{ domain }}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     client_max_body_size 10G;
#
#     location / {
#         proxy_pass http://nextcloud-backend:80;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#         proxy_set_header X-Forwarded-Host $server_name;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# =============================================================================
# KEYCLOAK - Identity Provider (HTTPS proxy)
# =============================================================================
# Expose Keycloak en HTTPS pour éviter les problèmes de mixed content
# Les applications OIDC utilisent https://keycloak.{{ domain }} au lieu de HTTP
#
# KEYCLOAK_BACKEND_URL supporte HTTP ou HTTPS :
#   - HTTP  : http://keycloak:8080, http://192.168.1.10:8080
#   - HTTPS : https://keycloak.example.com, https://192.168.1.10:8443
server {
    listen 443 ssl;
    http2 on;
    server_name {{ keycloak_proxy_hostname_resolved }};

    ssl_certificate /certs/wildcard.{{ domain }}.crt;
    ssl_certificate_key /certs/wildcard.{{ domain }}.key;

    # Proxy vers Keycloak (HTTP ou HTTPS selon KEYCLOAK_BACKEND_URL)
    # CORS est géré par Keycloak via webOrigins - ne PAS ajouter de headers CORS ici
    location / {
        set $upstream_keycloak "{{ oauth2_proxy_keycloak_upstream }}";
        proxy_pass $upstream_keycloak;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port 443;

        # Support HTTPS backend (certificats auto-signés acceptés)
        proxy_ssl_verify off;
        proxy_ssl_server_name on;

        # Buffers pour les réponses Keycloak (tokens peuvent être volumineux)
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
}
