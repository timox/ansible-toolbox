# Configuration Multi-Applications
# Template - Remplacer ${VAR} avec envsubst
#
# Architecture simplifiee :
# - Guacamole : OIDC natif vers Keycloak (pas d'oauth2-proxy)
# - Portail : oauth2-proxy pour authentification
# - Autres apps : oauth2-proxy ou OIDC natif selon l'application

# Resolver Docker pour résolution dynamique des upstreams
# Permet à nginx de démarrer même si certains services ne sont pas disponibles
resolver 127.0.0.11 valid=10s ipv6=off;

# Upstreams dynamiques (résolus à la demande, pas au démarrage)
# Utiliser ces variables dans proxy_pass pour éviter les erreurs si le service n'est pas encore up
map $host $upstream_oauth2 {
    default http://oauth2-proxy:4180;
}
map $host $upstream_guacamole {
    default http://guacamole-web:8080;
}
map $host $upstream_credentials {
    default http://credentials-api:5000;
}
map $host $upstream_portal_api {
    default http://portal-api:3000;
}

# Configuration commune WebSocket
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

# =============================================================================
# PORTAIL - Point d'entrée unique (default_server sur port 80)
# =============================================================================
server {
    listen 80 default_server;
    server_name _;

    root /usr/share/nginx/html/portal;
    index index.html;

    # Authentification obligatoire via oauth2-proxy
    auth_request /oauth2/auth;
    error_page 401 = /oauth2/sign_in;

    # Récupérer les informations utilisateur depuis oauth2-proxy
    auth_request_set $auth_user $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    auth_request_set $auth_groups $upstream_http_x_auth_request_groups;

    # Fichiers statiques du portail
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API endpoint - expose les headers oauth2-proxy en JSON
    location /api/user {
        default_type application/json;
        return 200 '{"email":"$http_x_forwarded_email","name":"$http_x_forwarded_preferred_username","user":"$http_x_forwarded_user","groups":"$http_x_forwarded_groups"}';
    }

    # API credentials - stockage securise des mots de passe RDP
    location /api/credentials {
        auth_request /oauth2/auth;
        error_page 401 = /oauth2/sign_in;
        auth_request_set $auth_user $upstream_http_x_auth_request_user;
        auth_request_set $auth_email $upstream_http_x_auth_request_email;
        auth_request_set $auth_groups $upstream_http_x_auth_request_groups;
        proxy_pass $upstream_credentials/api/credentials;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_user;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # API connections - liste les connexions Guacamole disponibles
    location /api/connections {
        auth_request /oauth2/auth;
        error_page 401 = /oauth2/sign_in;
        auth_request_set $auth_user $upstream_http_x_auth_request_user;
        auth_request_set $auth_email $upstream_http_x_auth_request_email;
        auth_request_set $auth_groups $upstream_http_x_auth_request_groups;
        proxy_pass $upstream_credentials/api/connections;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_user;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # API applications - gestion des applications du portail
    location /api/applications {
        auth_request /oauth2/auth;
        error_page 401 = /oauth2/sign_in;
        auth_request_set $auth_user $upstream_http_x_auth_request_user;
        auth_request_set $auth_email $upstream_http_x_auth_request_email;
        auth_request_set $auth_groups $upstream_http_x_auth_request_groups;
        proxy_pass $upstream_portal_api/api/applications;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # API categories - liste des categories d'applications
    location /api/categories {
        auth_request /oauth2/auth;
        error_page 401 = /oauth2/sign_in;
        proxy_pass $upstream_portal_api/api/categories;
        proxy_set_header Host $host;
    }

    # Logout oauth2-proxy uniquement (supprime cookie local)
    location = /oauth2/sign_out {
        auth_request off;
        proxy_pass $upstream_oauth2/oauth2/sign_out;
        proxy_set_header Host $host;
    }

    # Single Logout complet (oauth2-proxy + Keycloak)
    location = /logout {
        auth_request off;
        default_type text/html;
        return 200 '<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Deconnexion...</title>
    <script>
        // Supprimer les cookies oauth2-proxy
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Domain=.${DOMAIN}";

        // Appeler oauth2-proxy sign_out puis Keycloak logout
        fetch("/oauth2/sign_out", { method: "GET", credentials: "include" })
            .finally(function() {
                var keycloakLogout = "${KEYCLOAK_ISSUER}/protocol/openid-connect/logout";
                // Rediriger vers /oauth2/sign_in pour forcer la re-authentification
                var redirectUri = encodeURIComponent("https://portail.${DOMAIN}/oauth2/sign_in");
                window.location.href = keycloakLogout + "?post_logout_redirect_uri=" + redirectUri + "&client_id=${OIDC_CLIENT_ID}";
            });
    </script>
</head>
<body>
    <p>Deconnexion en cours...</p>
</body>
</html>';
    }

    # UserInfo - retourne les claims complets du token
    location /oauth2/userinfo {
        auth_request off;
        proxy_pass $upstream_oauth2;
        proxy_set_header Host $host;
    }

    location = /oauth2/auth {
        internal;
        proxy_pass $upstream_oauth2/oauth2/auth;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /oauth2/ {
        auth_request off;
        proxy_pass $upstream_oauth2;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Debug endpoint (headers reçus depuis oauth2-proxy en mode proxy)
    location /debug/headers {
        default_type text/plain;
        return 200 "Headers from oauth2-proxy (proxy mode):\nX-Forwarded-User: $http_x_forwarded_user\nX-Forwarded-Email: $http_x_forwarded_email\nX-Forwarded-Groups: $http_x_forwarded_groups\nX-Forwarded-Preferred-Username: $http_x_forwarded_preferred_username\n";
    }
}

# =============================================================================
# PORTAIL HTTPS - Interface web authentifiee
# =============================================================================
server {
    listen 443 ssl default_server;
    http2 on;
    server_name ${PORTAL_HOSTNAME} _;

    ssl_certificate /certs/wildcard.${DOMAIN}.crt;
    ssl_certificate_key /certs/wildcard.${DOMAIN}.key;

    root /usr/share/nginx/html/portal;
    index index.html;

    # Authentification via oauth2-proxy
    auth_request /oauth2/auth;
    error_page 401 = /oauth2/sign_in;

    # Recuperer les informations utilisateur depuis oauth2-proxy
    auth_request_set $auth_user $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    auth_request_set $auth_groups $upstream_http_x_auth_request_groups;
    auth_request_set $auth_preferred_username $upstream_http_x_auth_request_preferred_username;

    # Fichiers statiques du portail
    location / {
        try_files $uri $uri/ /index.html;
        # Pas de cache pour forcer re-authentification
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
        # Injecter les headers utilisateur pour le JavaScript
        add_header X-Auth-User $auth_user;
        add_header X-Auth-Email $auth_email;
        add_header X-Auth-Groups $auth_groups;
    }

    # API endpoint - expose les infos utilisateur en JSON
    # Proxy vers oauth2-proxy userinfo pour obtenir les claims
    location /api/user {
        auth_request off;
        proxy_pass $upstream_oauth2/oauth2/userinfo;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # API applications - liste des applications disponibles (statique)
    # TODO: Remplacer par un backend dynamique si necessaire
    location /api/applications {
        default_type application/json;
        return 200 '[{"id":"guacamole","name":"Guacamole","url":"https://guacamole.${DOMAIN}/guacamole/","icon":"desktop","description":"Bastion RDP/SSH/VNC","groups":["${ADMIN_GROUP}","${ADMIN_APP_GROUP}","${USER_GROUP}"]},{"id":"linshare","name":"LinShare","url":"https://linshare.${DOMAIN}/","icon":"folder","description":"Partage de fichiers","groups":["${ADMIN_GROUP}","${ADMIN_APP_GROUP}","${USER_GROUP}"]},{"id":"vaultwarden","name":"Vaultwarden","url":"https://vault.${DOMAIN}/","icon":"lock","description":"Gestionnaire de mots de passe","groups":["${ADMIN_GROUP}","${ADMIN_APP_GROUP}","${USER_GROUP}"]}]';
    }

    # API Keycloak clients - non disponible (fonctionnalite optionnelle)
    location /api/keycloak/clients {
        default_type application/json;
        return 200 '[]';
    }

    # API credentials - stockage securise des mots de passe RDP
    location /api/credentials {
        proxy_pass $upstream_credentials/api/credentials;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_preferred_username;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # API connections - liste les connexions Guacamole disponibles
    location /api/connections {
        proxy_pass $upstream_credentials/api/connections;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Preferred-Username $auth_preferred_username;
        proxy_set_header X-Forwarded-User $auth_user;
        proxy_set_header X-Forwarded-Email $auth_email;
        proxy_set_header X-Forwarded-Groups $auth_groups;
    }

    # Logout complet (oauth2-proxy + Keycloak)
    location = /logout {
        default_type text/html;
        return 200 '<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Deconnexion...</title>
    <script>
        // Supprimer tous les cookies oauth2-proxy
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
        document.cookie = "_oauth2_proxy=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Domain=.${DOMAIN}";
        document.cookie = "_oauth2_proxy_csrf=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
        document.cookie = "_oauth2_proxy_csrf=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Domain=.${DOMAIN}";

        // Appeler sign_out oauth2-proxy puis logout Keycloak
        fetch("/oauth2/sign_out", { method: "GET", credentials: "include" })
            .finally(function() {
                var keycloakLogout = "${KEYCLOAK_ISSUER}/protocol/openid-connect/logout";
                // Rediriger vers /oauth2/sign_in pour forcer la re-authentification
                var redirectUri = encodeURIComponent("https://portail.${DOMAIN}/oauth2/sign_in");
                window.location.href = keycloakLogout + "?post_logout_redirect_uri=" + redirectUri + "&client_id=${OIDC_CLIENT_ID}";
            });
    </script>
</head>
<body><p>Deconnexion en cours...</p></body>
</html>';
    }

    # Endpoints oauth2-proxy (exempts d'authentification)
    location /oauth2/ {
        auth_request off;
        proxy_pass $upstream_oauth2;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location = /oauth2/auth {
        internal;
        proxy_pass $upstream_oauth2/oauth2/auth;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Content-Length "";
        proxy_pass_request_body off;
    }
}

# =============================================================================
# GUACAMOLE - Bastion d'acces distant (OIDC natif)
# =============================================================================
# Architecture simplifiee : nginx (proxy SSL) -> Guacamole (OIDC -> Keycloak)
# L'authentification est geree directement par Guacamole via OpenID Connect
# Pas besoin d'oauth2-proxy ni de manipulation de headers

server {
    listen 443 ssl;
    http2 on;
    server_name ${GUACAMOLE_HOSTNAME};

    ssl_certificate /certs/wildcard.${DOMAIN}.crt;
    ssl_certificate_key /certs/wildcard.${DOMAIN}.key;

    # Proxy simple vers Guacamole (pas d'auth_request)
    # L'authentification OIDC est geree par Guacamole lui-meme
    location / {
        proxy_pass $upstream_guacamole;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support (critique pour Guacamole)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        proxy_buffering off;
    }
}

# GLPI - Gestion des tickets (admin-* et utilisateurs)
# IMPORTANT: Décommenter après avoir déployé glpi-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name glpi.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     location / {
#         proxy_pass http://glpi-backend:80;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# Zabbix - Monitoring (admin-* uniquement)
# IMPORTANT: Décommenter après avoir déployé zabbix-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name zabbix.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     # Restriction admin-*
#     set $authorized 0;
#     if ($groups ~ "admin-") {
#         set $authorized 1;
#     }
#     if ($authorized = 0) {
#         return 403 "Access forbidden - Admin group required";
#     }
#
#     location / {
#         proxy_pass http://zabbix-backend:8080;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# Nextcloud - Partage de fichiers (admin-* et utilisateurs)
# IMPORTANT: Décommenter après avoir déployé nextcloud-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name nextcloud.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     client_max_body_size 10G;
#
#     location / {
#         proxy_pass http://nextcloud-backend:80;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#         proxy_set_header X-Forwarded-Host $server_name;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# Wiki - Documentation interne (tous les utilisateurs)
# IMPORTANT: Décommenter après avoir déployé wiki-backend
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name ${BOOKSTACK_HOSTNAME};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     location / {
#         proxy_pass http://wiki-backend:80;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# vCenter - Administration VMware (admin-infra UNIQUEMENT)
# IMPORTANT: Décommenter après avoir configuré accès vCenter
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name vcenter.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#
#     # Restriction stricte admin-infra
#     set $authorized 0;
#     if ($groups ~ "admin-infra") {
#         set $authorized 1;
#     }
#     if ($authorized = 0) {
#         return 403 "Access forbidden - Infrastructure admin group required";
#     }
#
#     location / {
#         proxy_pass https://vcenter-backend:443;
#         proxy_set_header X-Forwarded-User $email;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header Host $host;
#         proxy_ssl_verify off;  # Si certificat auto-signé
#     }
#
#     location /oauth2/ {
#         proxy_pass https://oauth2-proxy:44180;
#         proxy_set_header Host $host;
#     }
# }

# =============================================================================
# LINSHARE - Extrait dans linshare.conf.template (genere conditionnellement)
# =============================================================================
# Si DEPLOY_LINSHARE=true, deploy.sh genere linshare.conf dans conf.d/
# Cela evite que nginx crashe si les containers LinShare ne sont pas deployes

# =============================================================================
# SYNC-IN - File Storage & Synchronization (tous les utilisateurs)
# =============================================================================
# Authentification via oauth2-proxy avec header-based auth
# Nécessite: PR header-auth mergée dans Sync-in OU build custom
# TODO: Configuration sync-in à finaliser (env vars non documentées)
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name sync-in.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     # Authentification via oauth2-proxy
#     auth_request /oauth2/auth;
#     error_page 401 = /oauth2/sign_in;
#
#     # Récupérer les headers utilisateur depuis oauth2-proxy
#     auth_request_set $user $upstream_http_x_auth_request_user;
#     auth_request_set $email $upstream_http_x_auth_request_email;
#     auth_request_set $groups $upstream_http_x_auth_request_groups;
#     auth_request_set $preferred_username $upstream_http_x_auth_request_preferred_username;
#
#     # Upload de fichiers volumineux
#     client_max_body_size 10G;
#     client_body_timeout 600s;
#     proxy_request_buffering off;
#
#     location / {
#         proxy_pass http://sync-in:8080;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_set_header X-Forwarded-Host $server_name;
#
#         # Headers d'authentification pour Sync-in (header-auth)
#         proxy_set_header X-Forwarded-User $user;
#         proxy_set_header X-Forwarded-Email $email;
#         proxy_set_header X-Forwarded-Groups $groups;
#         proxy_set_header X-Forwarded-Preferred-Username $preferred_username;
#
#         # Timeouts pour uploads longs
#         proxy_read_timeout 600s;
#         proxy_send_timeout 600s;
#         proxy_connect_timeout 60s;
#
#         # WebSocket support (si utilisé par Sync-in)
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection $connection_upgrade;
#     }
#
#     # Endpoint oauth2-proxy
#     location /oauth2/ {
#         proxy_pass $upstream_oauth2;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#     }
# }

# OnlyOffice Document Server (si activé)
# Accessible uniquement depuis Sync-in (pas d'auth externe)
# IMPORTANT: Décommenter si vous utilisez OnlyOffice avec Sync-in
# server {
#     listen 443 ssl;
#     http2 on;
#     server_name onlyoffice.${DOMAIN};
#
#     ssl_certificate /certs/wildcard.${DOMAIN}.crt;
#     ssl_certificate_key /certs/wildcard.${DOMAIN}.key;
#
#     # Pas d'auth_request - JWT interne entre Sync-in et OnlyOffice
#     # Accès restreint par firewall (uniquement depuis Sync-in)
#
#     location / {
#         proxy_pass http://sync-in-onlyoffice:80;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#
#         # WebSocket pour édition temps réel
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection $connection_upgrade;
#     }
# }

# =============================================================================
# HEADSCALE - VPN Mesh (API control plane + Headplane UI)
# =============================================================================
# Routage :
#   /admin*        → headplane:3000 (UI web, auth oauth2-proxy)
#   /oidc*         → headscale:8080 (callback OIDC clients VPN, pas d'auth nginx)
#   /ts2021, /noise, /key, /machine, /api, etc. → headscale:8080 (API VPN, pas d'auth nginx)
#   /              → redirect /admin/ (navigateurs)
server {
    listen 443 ssl;
    http2 on;
    server_name ${HEADSCALE_HOSTNAME};

    ssl_certificate /certs/wildcard.${DOMAIN}.crt;
    ssl_certificate_key /certs/wildcard.${DOMAIN}.key;

    # --- Headplane UI (auth oauth2-proxy) ---

    # Callback OIDC Headplane - exempt d'authentification oauth2-proxy
    location /admin/oidc/callback {
        set $upstream_headplane "http://headplane:3000";
        proxy_pass $upstream_headplane;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /admin {
        auth_request /oauth2/auth;
        error_page 401 = /oauth2/sign_in;

        auth_request_set $user $upstream_http_x_auth_request_user;
        auth_request_set $email $upstream_http_x_auth_request_email;
        auth_request_set $groups $upstream_http_x_auth_request_groups;

        set $upstream_headplane "http://headplane:3000";
        proxy_pass $upstream_headplane;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-User $email;
        proxy_set_header X-Forwarded-Email $email;
        proxy_set_header X-Forwarded-Groups $groups;
    }

    # --- Headscale API (clients VPN Tailscale, pas d'auth nginx) ---

    # OIDC callback pour enregistrement clients VPN
    location /oidc {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Noise protocol (Tailscale v2+)
    location /ts2021 {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 86400s;
        proxy_buffering off;
    }

    # Cle publique serveur
    location /key {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
    }

    # API Headscale (gRPC-web, REST)
    location /api/ {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Legacy machine registration
    location /machine {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Health check
    location /health {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
    }

    # Racine → redirect navigateurs vers Headplane UI
    # (les clients VPN n'utilisent pas /, ils utilisent /ts2021, /key, /machine)
    location = / {
        return 302 /admin/;
    }

    # Fallback → headscale API (tout ce qui n'est pas /admin*)
    location / {
        set $upstream_headscale "http://headscale:8080";
        proxy_pass $upstream_headscale;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # --- oauth2-proxy endpoints ---

    location /oauth2/ {
        proxy_pass $upstream_oauth2;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location = /oauth2/auth {
        internal;
        proxy_pass $upstream_oauth2/oauth2/auth;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Content-Length "";
        proxy_pass_request_body off;
    }
}

# =============================================================================
# VAULTWARDEN - Gestionnaire de mots de passe (SSO OIDC natif)
# =============================================================================
# Vaultwarden gere son propre SSO OIDC avec Keycloak (pas d'oauth2-proxy)
# Compatible avec tous les clients Bitwarden (mobile, desktop, navigateur)
# Administration: https://vault.${DOMAIN}/admin (token dans .env)
server {
    listen 443 ssl;
    http2 on;
    server_name ${VAULTWARDEN_HOSTNAME};

    ssl_certificate /certs/wildcard.${DOMAIN}.crt;
    ssl_certificate_key /certs/wildcard.${DOMAIN}.key;

    # Upload de fichiers (attachements)
    client_max_body_size 128M;

    # Proxy vers Vaultwarden (OIDC natif, pas d'auth_request)
    location / {
        set $upstream_vaultwarden "http://vaultwarden:80";
        proxy_pass $upstream_vaultwarden;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $server_name;
    }

    # WebSocket pour synchronisation temps reel
    location /notifications/hub {
        set $upstream_vaultwarden "http://vaultwarden:80";
        proxy_pass $upstream_vaultwarden;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }
}

# =============================================================================
# KEYCLOAK - Identity Provider (HTTPS proxy)
# =============================================================================
# Expose Keycloak en HTTPS pour éviter les problèmes de mixed content
# Les applications OIDC utilisent https://keycloak.${DOMAIN} au lieu de HTTP
#
# KEYCLOAK_BACKEND_URL supporte HTTP ou HTTPS :
#   - HTTP  : http://keycloak:8080, http://192.168.1.10:8080
#   - HTTPS : https://keycloak.example.com, https://192.168.1.10:8443
server {
    listen 443 ssl;
    http2 on;
    server_name ${KEYCLOAK_PROXY_HOSTNAME};

    ssl_certificate /certs/wildcard.${DOMAIN}.crt;
    ssl_certificate_key /certs/wildcard.${DOMAIN}.key;

    # Proxy vers Keycloak (HTTP ou HTTPS selon KEYCLOAK_BACKEND_URL)
    # CORS est géré par Keycloak via webOrigins - ne PAS ajouter de headers CORS ici
    location / {
        set $upstream_keycloak "${KEYCLOAK_BACKEND_URL}";
        proxy_pass $upstream_keycloak;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port 443;

        # Support HTTPS backend (certificats auto-signés acceptés)
        proxy_ssl_verify off;
        proxy_ssl_server_name on;

        # Buffers pour les réponses Keycloak (tokens peuvent être volumineux)
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
}
